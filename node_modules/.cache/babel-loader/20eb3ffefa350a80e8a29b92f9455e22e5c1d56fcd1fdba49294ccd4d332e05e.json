{"ast":null,"code":"import { ElementEvent, MutationEvent, runtime } from '@antv/g-lite';\nvar MutationRecord = /** @class */function () {\n  function MutationRecord(type, target) {\n    this.type = type;\n    this.target = target;\n    this.addedNodes = [];\n    this.attributeName = null;\n    this.attributeNamespace = null;\n    this.nextSibling = null;\n    this.oldValue = null;\n    this.previousSibling = null;\n    this.removedNodes = [];\n  }\n  MutationRecord.copy = function (original) {\n    var record = new MutationRecord(original.type, original.target);\n    record.addedNodes = original.addedNodes.slice();\n    record.removedNodes = original.removedNodes.slice();\n    record.previousSibling = original.previousSibling;\n    record.nextSibling = original.nextSibling;\n    record.attributeName = original.attributeName;\n    record.attributeNamespace = original.attributeNamespace;\n    record.oldValue = original.oldValue;\n    return record;\n  };\n  return MutationRecord;\n}();\nvar uidCounter = 0;\nvar registrationsTable = new WeakMap();\nvar Registration = /** @class */function () {\n  function Registration(observer, target, options) {\n    this.observer = observer;\n    this.target = target;\n    this.options = options;\n    this.transientObservedNodes = [];\n  }\n  Registration.prototype.enqueue = function (record) {\n    var records = this.observer.records;\n    var length = records.length;\n    // There are cases where we replace the last record with the new record.\n    // For example if the record represents the same mutation we need to use\n    // the one with the oldValue. If we get same record (this can happen as we\n    // walk up the tree) we ignore the new record.\n    if (records.length > 0) {\n      var lastRecord = records[length - 1];\n      var recordToReplaceLast = selectRecord(lastRecord, record);\n      if (recordToReplaceLast) {\n        records[length - 1] = recordToReplaceLast;\n        return;\n      }\n    } else {\n      scheduleCallback(this.observer);\n    }\n    records[length] = record;\n  };\n  Registration.prototype.addListeners = function () {\n    this.addListeners_(this.target);\n  };\n  Registration.prototype.addListeners_ = function (node) {\n    var options = this.options;\n    if (options.attributes) node.addEventListener(ElementEvent.ATTR_MODIFIED, this, true);\n    // if (options.characterData) node.addEventListener('DOMCharacterDataModified', this, true);\n    if (options.childList) node.addEventListener(ElementEvent.INSERTED, this, true);\n    if (options.childList || options.subtree) node.addEventListener(ElementEvent.REMOVED, this, true);\n  };\n  Registration.prototype.removeListeners = function () {\n    this.removeListeners_(this.target);\n  };\n  Registration.prototype.removeListeners_ = function (node) {\n    var options = this.options;\n    if (options.attributes) node.removeEventListener(ElementEvent.ATTR_MODIFIED, this, true);\n    // if (options.characterData) node.removeEventListener('DOMCharacterDataModified', this, true);\n    if (options.childList) node.removeEventListener(ElementEvent.INSERTED, this, true);\n    if (options.childList || options.subtree) node.removeEventListener(ElementEvent.REMOVED, this, true);\n  };\n  /**\n   * Adds a transient observer on node. The transient observer gets removed\n   * next time we deliver the change records.\n   */\n  // addTransientObserver(node: IElement) {\n  //   // Don't add transient observers on the target itself. We already have all\n  //   // the required listeners set up on the target.\n  //   if (node === this.target) return;\n  //   this.addListeners_(node);\n  //   this.transientObservedNodes.push(node);\n  //   let registrations = registrationsTable.get(node);\n  //   if (!registrations) registrationsTable.set(node, (registrations = []));\n  //   // We know that registrations does not contain this because we already\n  //   // checked if node === this.target.\n  //   registrations.push(this);\n  // }\n  Registration.prototype.removeTransientObservers = function () {\n    var transientObservedNodes = this.transientObservedNodes;\n    this.transientObservedNodes = [];\n    transientObservedNodes.forEach(function (node) {\n      // Transient observers are never added to the target.\n      this.removeListeners_(node);\n      var registrations = registrationsTable.get(node);\n      for (var i = 0; i < registrations.length; i++) {\n        if (registrations[i] === this) {\n          registrations.splice(i, 1);\n          // Each node can only have one registered observer associated with\n          // this observer.\n          break;\n        }\n      }\n    }, this);\n  };\n  Registration.prototype.handleEvent = function (e) {\n    // Stop propagation since we are managing the propagation manually.\n    // This means that other mutation events on the page will not work\n    // correctly but that is by design.\n    e.stopImmediatePropagation();\n    var record;\n    var target;\n    switch (e.type) {\n      case ElementEvent.ATTR_MODIFIED:\n        // http://dom.spec.whatwg.org/#concept-mo-queue-attributes\n        var name_1 = e.attrName;\n        // @ts-ignore\n        var namespace_1 = e.relatedNode.namespaceURI;\n        target = e.target;\n        // 1.\n        record = getRecord('attributes', target);\n        record.attributeName = name_1;\n        record.attributeNamespace = namespace_1;\n        // 2.\n        var oldValue_1 = e.attrChange === MutationEvent.ADDITION ? null : e.prevValue;\n        forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n          // 3.1, 4.2\n          if (!options.attributes) return;\n          // 3.2, 4.3\n          if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name_1) === -1 && options.attributeFilter.indexOf(namespace_1) === -1) {\n            return;\n          }\n          // 3.3, 4.4\n          if (options.attributeOldValue) return getRecordWithOldValue(oldValue_1);\n          // 3.4, 4.5\n          return record;\n        });\n        break;\n      // case 'DOMCharacterDataModified':\n      //   // http://dom.spec.whatwg.org/#concept-mo-queue-characterdata\n      //   var target = e.target;\n      //   // 1.\n      //   var record = getRecord('characterData', target);\n      //   // 2.\n      //   var oldValue = e.prevValue;\n      //   forEachAncestorAndObserverEnqueueRecord(target, function(options) {\n      //     // 3.1, 4.2\n      //     if (!options.characterData)\n      //       return;\n      //     // 3.2, 4.3\n      //     if (options.characterDataOldValue)\n      //       return getRecordWithOldValue(oldValue);\n      //     // 3.3, 4.4\n      //     return record;\n      //   });\n      //   break;\n      case ElementEvent.REMOVED:\n      // this.addTransientObserver(e.target as IElement);\n      // Fall through.\n      case ElementEvent.INSERTED:\n        // http://dom.spec.whatwg.org/#concept-mo-queue-childlist\n        target = e.relatedNode;\n        var changedNode = e.target;\n        var addedNodes = void 0;\n        var removedNodes = void 0;\n        if (e.type === ElementEvent.INSERTED) {\n          addedNodes = [changedNode];\n          removedNodes = [];\n        } else {\n          addedNodes = [];\n          removedNodes = [changedNode];\n        }\n        var previousSibling = changedNode.previousSibling;\n        var nextSibling = changedNode.nextSibling;\n        // 1.\n        record = getRecord('childList', target);\n        record.addedNodes = addedNodes;\n        record.removedNodes = removedNodes;\n        record.previousSibling = previousSibling;\n        record.nextSibling = nextSibling;\n        forEachAncestorAndObserverEnqueueRecord(target, function (options) {\n          // 2.1, 3.2\n          if (!options.childList) return;\n          // 2.2, 3.3\n          return record;\n        });\n    }\n    clearRecords();\n  };\n  return Registration;\n}();\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver\n * @see https://github.com/googlearchive/MutationObservers/blob/master/MutationObserver.js\n */\nvar MutationObserver = /** @class */function () {\n  function MutationObserver(callback) {\n    this.callback = callback;\n    this.nodes = [];\n    this.records = [];\n    this.uid = uidCounter++;\n  }\n  MutationObserver.prototype.observe = function (target, options) {\n    // 1.1\n    if (!options.childList && !options.attributes && !options.characterData ||\n    // 1.2\n    options.attributeOldValue && !options.attributes ||\n    // 1.3\n    options.attributeFilter && options.attributeFilter.length && !options.attributes ||\n    // 1.4\n    options.characterDataOldValue && !options.characterData) {\n      throw new SyntaxError();\n    }\n    var registrations = registrationsTable.get(target);\n    if (!registrations) registrationsTable.set(target, registrations = []);\n    // 2\n    // If target's list of registered observers already includes a registered\n    // observer associated with the context object, replace that registered\n    // observer's options with options.\n    var registration;\n    for (var i = 0; i < registrations.length; i++) {\n      if (registrations[i].observer === this) {\n        registration = registrations[i];\n        registration.removeListeners();\n        registration.options = options;\n        break;\n      }\n    }\n    // 3.\n    // Otherwise, add a new registered observer to target's list of registered\n    // observers with the context object as the observer and options as the\n    // options, and add target to context object's list of nodes on which it\n    // is registered.\n    if (!registration) {\n      registration = new Registration(this, target, options);\n      registrations.push(registration);\n      this.nodes.push(target);\n    }\n    registration.addListeners();\n  };\n  MutationObserver.prototype.disconnect = function () {\n    var _this = this;\n    this.nodes.forEach(function (node) {\n      var registrations = registrationsTable.get(node);\n      for (var i = 0; i < registrations.length; i++) {\n        var registration = registrations[i];\n        if (registration.observer === _this) {\n          registration.removeListeners();\n          registrations.splice(i, 1);\n          // Each node can only have one registered observer associated with\n          // this observer.\n          break;\n        }\n      }\n    }, this);\n    this.records = [];\n  };\n  MutationObserver.prototype.takeRecords = function () {\n    var copyOfRecords = this.records;\n    this.records = [];\n    return copyOfRecords;\n  };\n  return MutationObserver;\n}();\n// We keep track of the two (possibly one) records used in a single mutation.\nvar currentRecord;\nvar recordWithOldValue;\n/**\n * Creates a record without |oldValue| and caches it as |currentRecord| for\n * later use.\n */\nfunction getRecord(type, target) {\n  return currentRecord = new MutationRecord(type, target);\n}\n/**\n * Gets or creates a record with |oldValue| based in the |currentRecord|\n */\nfunction getRecordWithOldValue(oldValue) {\n  if (recordWithOldValue) return recordWithOldValue;\n  recordWithOldValue = MutationRecord.copy(currentRecord);\n  recordWithOldValue.oldValue = oldValue;\n  return recordWithOldValue;\n}\nfunction clearRecords() {\n  currentRecord = recordWithOldValue = undefined;\n}\n/**\n * Whether the record represents a record from the current\n * mutation event.\n */\nfunction recordRepresentsCurrentMutation(record) {\n  return record === recordWithOldValue || record === currentRecord;\n}\n/**\n * Selects which record, if any, to replace the last record in the queue.\n * This returns |null| if no record should be replaced.\n */\nfunction selectRecord(lastRecord, newRecord) {\n  if (lastRecord === newRecord) return lastRecord;\n  // Check if the the record we are adding represents the same record. If\n  // so, we keep the one with the oldValue in it.\n  if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord)) return recordWithOldValue;\n  return null;\n}\nfunction removeTransientObserversFor(observer) {\n  observer.nodes.forEach(function (node) {\n    var registrations = registrationsTable.get(node);\n    if (!registrations) return;\n    registrations.forEach(function (registration) {\n      if (registration.observer === observer) registration.removeTransientObservers();\n    });\n  });\n}\n/**\n * This function is used for the \"For each registered observer observer (with\n * observer's options as options) in target's list of registered observers,\n * run these substeps:\" and the \"For each ancestor ancestor of target, and for\n * each registered observer observer (with options options) in ancestor's list\n * of registered observers, run these substeps:\" part of the algorithms. The\n * |options.subtree| is checked to ensure that the callback is called\n * correctly.\n *\n * @param {Node} target\n * @param {function(MutationObserverInit):MutationRecord} callback\n */\nfunction forEachAncestorAndObserverEnqueueRecord(target, callback) {\n  for (var node = target; node; node = node.parentNode) {\n    var registrations = registrationsTable.get(node);\n    if (registrations) {\n      for (var j = 0; j < registrations.length; j++) {\n        var registration = registrations[j];\n        var options = registration.options;\n        // Only target ignores subtree.\n        if (node !== target && !options.subtree) continue;\n        var record = callback(options);\n        if (record) registration.enqueue(record);\n      }\n    }\n  }\n}\n// This is used to ensure that we never schedule 2 callas to setImmediate\nvar isScheduled = false;\n// Keep track of observers that needs to be notified next time.\nvar scheduledObservers = [];\n/**\n * Schedules |dispatchCallback| to be called in the future.\n */\nfunction scheduleCallback(observer) {\n  scheduledObservers.push(observer);\n  if (!isScheduled) {\n    isScheduled = true;\n    // setImmediate(dispatchCallbacks);\n    if (typeof runtime.globalThis !== 'undefined') {\n      runtime.globalThis.setTimeout(dispatchCallbacks);\n    } else {\n      dispatchCallbacks();\n    }\n  }\n}\nfunction dispatchCallbacks() {\n  // http://dom.spec.whatwg.org/#mutation-observers\n  isScheduled = false; // Used to allow a new setImmediate call above.\n  var observers = scheduledObservers;\n  scheduledObservers = [];\n  // Sort observers based on their creation UID (incremental).\n  observers.sort(function (o1, o2) {\n    return o1.uid - o2.uid;\n  });\n  var anyNonEmpty = false;\n  observers.forEach(function (observer) {\n    // 2.1, 2.2\n    var queue = observer.takeRecords();\n    // 2.3. Remove all transient registered observers whose observer is mo.\n    removeTransientObserversFor(observer);\n    // 2.4\n    if (queue.length) {\n      // @ts-ignore\n      observer.callback(queue, observer);\n      anyNonEmpty = true;\n    }\n  });\n  // 3.\n  if (anyNonEmpty) dispatchCallbacks();\n}\nexport { MutationObserver, MutationRecord, Registration };","map":{"version":3,"names":["MutationRecord","type","target","addedNodes","attributeName","attributeNamespace","nextSibling","oldValue","previousSibling","removedNodes","copy","original","record","slice","uidCounter","registrationsTable","WeakMap","Registration","observer","options","transientObservedNodes","prototype","enqueue","records","length","lastRecord","recordToReplaceLast","selectRecord","scheduleCallback","addListeners","addListeners_","node","attributes","addEventListener","ElementEvent","ATTR_MODIFIED","childList","INSERTED","subtree","REMOVED","removeListeners","removeListeners_","removeEventListener","removeTransientObservers","forEach","registrations","get","i","splice","handleEvent","e","stopImmediatePropagation","name_1","attrName","namespace_1","relatedNode","namespaceURI","getRecord","oldValue_1","attrChange","MutationEvent","ADDITION","prevValue","forEachAncestorAndObserverEnqueueRecord","attributeFilter","indexOf","attributeOldValue","getRecordWithOldValue","changedNode","clearRecords","MutationObserver","callback","nodes","uid","observe","characterData","characterDataOldValue","SyntaxError","set","registration","push","disconnect","_this","takeRecords","copyOfRecords","currentRecord","recordWithOldValue","undefined","recordRepresentsCurrentMutation","newRecord","removeTransientObserversFor","parentNode","j","isScheduled","scheduledObservers","runtime","globalThis","setTimeout","dispatchCallbacks","observers","sort","o1","o2","anyNonEmpty","queue"],"sources":["../src/packages/g-dom-mutation-observer-api/src/dom/MutationRecord.ts","../src/packages/g-dom-mutation-observer-api/src/dom/MutationObserver.ts"],"sourcesContent":[null,null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}