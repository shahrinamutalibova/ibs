{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport { Category } from '@antv/component';\nimport { last } from '@antv/util';\nimport { format } from 'd3-format';\nimport { Identity } from '@antv/scale';\nimport { useMarker } from '../utils/marker';\nimport { adaptor, domainOf, LegendCategoryLayout, inferComponentLayout, inferComponentShape, scaleOf, titleContent } from './utils';\nfunction inferShape(scales, markState) {\n  const shapeScale = scaleOf(scales, 'shape');\n  const colorScale = scaleOf(scales, 'color');\n  // NOTE!!!\n  // scaleOrdinal.map will mute domain.\n  const shapeScale1 = shapeScale ? shapeScale.clone() : null;\n  // Infer the main shape if multiple marks are used.\n  const shapes = [];\n  for (const [mark, state] of markState) {\n    const namespace = mark.type;\n    const domain = (colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain.length) > 0 ? colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain : state.data;\n    const shape = domain.map((d, i) => {\n      var _a;\n      if (shapeScale1) return shapeScale1.map(d || 'point');\n      return ((_a = mark === null || mark === void 0 ? void 0 : mark.style) === null || _a === void 0 ? void 0 : _a.shape) || state.defaultShape || 'point';\n    });\n    if (typeof namespace === 'string') shapes.push([namespace, shape]);\n  }\n  if (shapes.length === 0) return ['point', ['point']];\n  if (shapes.length === 1) return shapes[0];\n  if (!shapeScale) return shapes[0];\n  // Evaluate the maximum likelihood of shape\n  const {\n    range\n  } = shapeScale.getOptions();\n  return shapes.map(([namespace, shape]) => {\n    let sum = 0;\n    for (let i = 0; i < shapes.length; i++) {\n      const targetShape = range[i % range.length];\n      if (shape[i] === targetShape) sum++;\n    }\n    return [sum / shape.length, [namespace, shape]];\n  }).sort((a, b) => b[0] - a[0])[0][1];\n}\nfunction inferItemMarker(options, context) {\n  const {\n    scales,\n    library,\n    markState\n  } = context;\n  const [mark, shapes] = inferShape(scales, markState);\n  const {\n    itemMarker,\n    itemMarkerSize: size\n  } = options;\n  const create = (name, d) => {\n    var _a, _b, _c;\n    const marker = ((_c = (_b = (_a = library[`mark.${mark}`]) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.shape[name]) === null || _c === void 0 ? void 0 : _c.props.defaultMarker) || last(name.split('.'));\n    const radius = typeof size === 'function' ? size(d) : size;\n    return () => useMarker(marker, {\n      color: d.color\n    })(0, 0, radius);\n  };\n  const shapeOf = i => `${shapes[i]}`;\n  const shapeScale = scaleOf(scales, 'shape');\n  if (shapeScale && !itemMarker) return (d, i) => create(shapeOf(i), d);\n  if (typeof itemMarker === 'function') {\n    return (d, i) => {\n      // @todo Fix this in GUI.\n      // It should pass primitive value rather object.\n      const node = itemMarker(d.id, i);\n      if (typeof node === 'string') return create(node, d);\n      return node;\n    };\n  }\n  return (d, i) => create(itemMarker || shapeOf(i), d);\n}\nfunction inferItemMarkerOpacity(scales) {\n  const scale = scaleOf(scales, 'opacity');\n  if (scale) {\n    const {\n      range\n    } = scale.getOptions();\n    return (d, i) => range[i];\n  }\n  return undefined;\n}\nfunction inferItemMarkerSize(scales, defaults) {\n  const scale = scaleOf(scales, 'size');\n  if (scale instanceof Identity) return scale.map(NaN) * 2;\n  return defaults;\n}\nfunction inferCategoryStyle(options, context) {\n  const {\n    labelFormatter = d => `${d}`\n  } = options;\n  const {\n    scales,\n    theme\n  } = context;\n  const defaultSize = theme.legendCategory.itemMarkerSize;\n  const itemMarkerSize = inferItemMarkerSize(scales, defaultSize);\n  const baseStyle = {\n    itemMarker: inferItemMarker(Object.assign(Object.assign({}, options), {\n      itemMarkerSize\n    }), context),\n    itemMarkerSize: itemMarkerSize,\n    itemMarkerOpacity: inferItemMarkerOpacity(scales)\n  };\n  const finalLabelFormatter = typeof labelFormatter === 'string' ? format(labelFormatter) : labelFormatter;\n  const colorScale = scaleOf(scales, 'color');\n  const domain = domainOf(scales);\n  const colorOf = colorScale ? d => colorScale.map(d) : () => context.theme.color;\n  return Object.assign(Object.assign({}, baseStyle), {\n    data: domain.map(d => ({\n      id: d,\n      label: finalLabelFormatter(d),\n      color: colorOf(d)\n    }))\n  });\n}\nfunction inferLegendShape(value, options, component) {\n  const {\n    position\n  } = options;\n  if (position === 'center') {\n    const {\n      bbox\n    } = value;\n    // to be confirm: if position is center, we should use the width and height of user definition.\n    const {\n      width,\n      height\n    } = bbox;\n    return {\n      width,\n      height\n    };\n  }\n  const {\n    width,\n    height\n  } = inferComponentShape(value, options, component);\n  return {\n    width,\n    height\n  };\n}\n/**\n * Guide Component for ordinal color scale.\n */\nexport const LegendCategory = options => {\n  const {\n      labelFormatter,\n      layout,\n      order,\n      orientation,\n      position,\n      size,\n      title,\n      cols,\n      itemMarker\n    } = options,\n    style = __rest(options, [\"labelFormatter\", \"layout\", \"order\", \"orientation\", \"position\", \"size\", \"title\", \"cols\", \"itemMarker\"]);\n  const {\n    gridRow\n  } = style;\n  return context => {\n    const {\n      value,\n      theme\n    } = context;\n    const {\n      bbox\n    } = value;\n    const {\n      width,\n      height\n    } = inferLegendShape(value, options, LegendCategory);\n    const finalLayout = inferComponentLayout(position, layout);\n    const legendStyle = Object.assign(Object.assign(Object.assign(Object.assign({\n      orientation: ['right', 'left', 'center'].includes(position) ? 'vertical' : 'horizontal',\n      width,\n      height,\n      layout: cols !== undefined ? 'grid' : 'flex'\n    }, cols !== undefined && {\n      gridCol: cols\n    }), gridRow !== undefined && {\n      gridRow\n    }), {\n      titleText: titleContent(title)\n    }), inferCategoryStyle(options, context));\n    const {\n      legendCategory: legendTheme = {}\n    } = theme;\n    const categoryStyle = adaptor(Object.assign({}, legendTheme, legendStyle, style));\n    const layoutWrapper = new LegendCategoryLayout({\n      style: Object.assign(Object.assign({\n        x: bbox.x,\n        y: bbox.y,\n        width: bbox.width,\n        height: bbox.height\n      }, finalLayout), {\n        // @ts-ignore\n        subOptions: categoryStyle\n      })\n    });\n    layoutWrapper.appendChild(new Category({\n      className: 'legend-category',\n      style: categoryStyle\n    }));\n    return layoutWrapper;\n  };\n};\nLegendCategory.props = {\n  defaultPosition: 'top',\n  defaultOrder: 1,\n  defaultSize: 40,\n  defaultCrossPadding: [12, 12],\n  defaultPadding: [12, 12]\n};","map":{"version":3,"names":["Category","last","format","Identity","useMarker","adaptor","domainOf","LegendCategoryLayout","inferComponentLayout","inferComponentShape","scaleOf","titleContent","inferShape","scales","markState","shapeScale","colorScale","shapeScale1","clone","shapes","mark","state","namespace","type","domain","getOptions","length","data","shape","map","d","i","_a","style","defaultShape","push","range","sum","targetShape","sort","a","b","inferItemMarker","options","context","library","itemMarker","itemMarkerSize","size","create","name","marker","_c","_b","props","defaultMarker","split","radius","color","shapeOf","node","id","inferItemMarkerOpacity","scale","undefined","inferItemMarkerSize","defaults","NaN","inferCategoryStyle","labelFormatter","theme","defaultSize","legendCategory","baseStyle","Object","assign","itemMarkerOpacity","finalLabelFormatter","colorOf","label","inferLegendShape","value","component","position","bbox","width","height","LegendCategory","layout","order","orientation","title","cols","__rest","gridRow","finalLayout","legendStyle","includes","gridCol","titleText","legendTheme","categoryStyle","layoutWrapper","x","y","subOptions","appendChild","className","defaultPosition","defaultOrder","defaultCrossPadding","defaultPadding"],"sources":["component/legendCategory.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}