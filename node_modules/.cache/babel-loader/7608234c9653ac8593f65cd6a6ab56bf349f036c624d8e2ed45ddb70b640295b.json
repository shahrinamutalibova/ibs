{"ast":null,"code":"import { Linear, createInterpolateValue } from '@antv/scale';\nimport { extent, max } from 'd3-array';\nimport * as d3ScaleChromatic from 'd3-scale-chromatic';\nimport { deepMix, omit, upperFirst } from '@antv/util';\nimport { firstOf, lastOf, unique } from '../utils/array';\nimport { defined, identity, isStrictObject } from '../utils/helper';\nimport { isTheta } from './coordinate';\nimport { useLibrary } from './library';\nexport function inferScale(name, values, options, coordinates, theme, library) {\n  const {\n    guide = {}\n  } = options;\n  const type = inferScaleType(name, values, options);\n  if (typeof type !== 'string') return options;\n  const expectedDomain = inferScaleDomain(type, name, values, options);\n  const actualDomain = maybeRatio(type, expectedDomain, options);\n  return Object.assign(Object.assign(Object.assign({}, options), inferScaleOptions(type, name, values, options, coordinates)), {\n    domain: actualDomain,\n    range: inferScaleRange(type, name, values, options, actualDomain, theme, library),\n    expectedDomain,\n    guide,\n    name,\n    type\n  });\n}\nexport function applyScale(channels, scale) {\n  const scaledValue = {};\n  for (const channel of channels) {\n    const {\n      values,\n      name: scaleName\n    } = channel;\n    const scaleInstance = scale[scaleName];\n    for (const value of values) {\n      const {\n        name,\n        value: V\n      } = value;\n      scaledValue[name] = V.map(d => scaleInstance.map(d));\n    }\n  }\n  return scaledValue;\n}\nexport function collectScales(states, options) {\n  var _a;\n  const {\n    components = []\n  } = options;\n  const NONE_STATIC_KEYS = ['scale', 'encode', 'axis', 'legend', 'data', 'transform'];\n  // From normal marks.\n  const scales = Array.from(new Set(states.flatMap(d => d.channels.map(d => d.scale))));\n  // From static marks.\n  const nameScale = new Map(scales.map(scale => [scale.name, scale]));\n  for (const component of components) {\n    const channels = inferChannelsForComponent(component);\n    for (const channel of channels) {\n      const scale = nameScale.get(channel);\n      const staticScale = ((_a = component.scale) === null || _a === void 0 ? void 0 : _a[channel]) || {};\n      const {\n        independent = false\n      } = staticScale;\n      if (scale && !independent) {\n        // Merged with exist scales if is not independent.\n        const {\n          guide\n        } = scale;\n        const guide1 = typeof guide === 'boolean' ? {} : guide;\n        scale.guide = deepMix({}, guide1, component);\n        Object.assign(scale, staticScale);\n      } else {\n        // Append new scales without exit scales or independent.\n        const options1 = Object.assign(Object.assign({}, staticScale), {\n          expectedDomain: staticScale.domain,\n          name: channel,\n          guide: omit(component, NONE_STATIC_KEYS)\n        });\n        scales.push(options1);\n      }\n    }\n  }\n  return scales;\n}\nexport function useRelation(relations) {\n  if (!relations || !Array.isArray(relations)) return [identity, identity];\n  // Store original map and invert.\n  let map;\n  let invert;\n  const conditionalize = scale => {\n    var _a;\n    map = scale.map.bind(scale);\n    invert = (_a = scale.invert) === null || _a === void 0 ? void 0 : _a.bind(scale);\n    // Distinguish functions[function, output] and value[vale, output] relations.\n    const funcRelations = relations.filter(([v]) => typeof v === 'function');\n    const valueRelations = relations.filter(([v]) => typeof v !== 'function');\n    // Update scale.map\n    const valueOutput = new Map(valueRelations);\n    scale.map = x => {\n      for (const [verify, value] of funcRelations) {\n        if (verify(x)) return value;\n      }\n      if (valueOutput.has(x)) return valueOutput.get(x);\n      return map(x);\n    };\n    if (!invert) return scale;\n    // Update scale.invert\n    const outputValue = new Map(valueRelations.map(([a, b]) => [b, a]));\n    const outputFunc = new Map(funcRelations.map(([a, b]) => [b, a]));\n    scale.invert = x => {\n      if (outputFunc.has(x)) return x;\n      if (outputValue.has(x)) return outputValue.get(x);\n      return invert(x);\n    };\n    return scale;\n  };\n  const deconditionalize = scale => {\n    if (map !== null) scale.map = map;\n    if (invert !== null) scale.invert = invert;\n    return scale;\n  };\n  return [conditionalize, deconditionalize];\n}\nexport function assignScale(target, source) {\n  const keys = Object.keys(target);\n  for (const scale of Object.values(source)) {\n    const {\n      name\n    } = scale.getOptions();\n    if (!(name in target)) target[name] = scale;else {\n      const I = keys.filter(d => d.startsWith(name))\n      // Reg is for extract `1` from `x1`;\n      .map(d => +(d.replace(name, '') || 0));\n      const index = max(I) + 1;\n      const newKey = `${name}${index}`;\n      target[newKey] = scale;\n      scale.getOptions().key = newKey;\n    }\n  }\n  return target;\n}\nexport function useRelationScale(options, library) {\n  const [useScale] = useLibrary('scale', library);\n  const {\n    relations\n  } = options;\n  const [conditionalize] = useRelation(relations);\n  const scale = useScale(options);\n  return conditionalize(scale);\n}\nexport function syncFacetsScales(states) {\n  const scales = states.flatMap(d => Array.from(d.values())).flatMap(d => d.channels.map(d => d.scale));\n  syncFacetsScaleByChannel(scales, 'x');\n  syncFacetsScaleByChannel(scales, 'y');\n}\nfunction inferChannelsForComponent(component) {\n  const {\n    channels = [],\n    type,\n    scale = {}\n  } = component;\n  const L = ['shape', 'color', 'opacity', 'size'];\n  if (channels.length !== 0) return channels;\n  if (type === 'axisX') return ['x'];\n  if (type === 'axisY') return ['y'];\n  if (type === 'legends') return Object.keys(scale).filter(d => L.includes(d));\n  return [];\n}\nfunction syncFacetsScaleByChannel(scales, channel) {\n  const S = scales.filter(({\n    name,\n    facet = true\n  }) => facet && name === channel);\n  const D = S.flatMap(d => d.domain);\n  const syncedD = S.every(isQuantitativeScale) ? extent(D) : S.every(isDiscreteScale) ? Array.from(new Set(D)) : null;\n  if (syncedD === null) return;\n  for (const scale of S) {\n    scale.domain = syncedD;\n  }\n}\nfunction maybeRatio(type, domain, options) {\n  const {\n    ratio\n  } = options;\n  if (ratio === undefined || ratio === null) return domain;\n  if (isQuantitativeScale({\n    type\n  })) {\n    return clampQuantitativeScale(domain, ratio, type);\n  }\n  if (isDiscreteScale({\n    type\n  })) return clampDiscreteScale(domain, ratio);\n  return domain;\n}\nfunction clampQuantitativeScale(domain, ratio, type) {\n  const D = domain.map(Number);\n  const scale = new Linear({\n    domain: D,\n    range: [D[0], D[0] + (D[D.length - 1] - D[0]) * ratio]\n  });\n  if (type === 'time') return domain.map(d => new Date(scale.map(d)));\n  return domain.map(d => scale.map(d));\n}\nfunction clampDiscreteScale(domain, ratio) {\n  const index = Math.round(domain.length * ratio);\n  return domain.slice(0, index);\n}\nfunction isQuantitativeScale(scale) {\n  const {\n    type\n  } = scale;\n  if (typeof type !== 'string') return false;\n  // Do not take quantize, quantile or threshold scale into account,\n  // because they are not for position scales. If they are, there is\n  // no need to sync them.\n  const names = ['linear', 'log', 'pow', 'time'];\n  return names.includes(type);\n}\nfunction isDiscreteScale(scale) {\n  const {\n    type\n  } = scale;\n  if (typeof type !== 'string') return false;\n  const names = ['band', 'point', 'ordinal'];\n  return names.includes(type);\n}\n// @todo More accurate inference for different cases.\nfunction inferScaleType(name, values, options) {\n  const {\n    type,\n    domain,\n    range,\n    quantitative,\n    ordinal\n  } = options;\n  if (type !== undefined) return type;\n  if (isObject(values)) return 'identity';\n  if (typeof range === 'string') return 'linear';\n  if ((domain || range || []).length > 2) return asOrdinalType(name, ordinal);\n  if (domain !== undefined) {\n    if (isOrdinal([domain])) return asOrdinalType(name, ordinal);\n    if (isTemporal(values)) return 'time';\n    return asQuantitativeType(name, range, quantitative);\n  }\n  if (isOrdinal(values)) return asOrdinalType(name, ordinal);\n  if (isTemporal(values)) return 'time';\n  return asQuantitativeType(name, range, quantitative);\n}\nfunction inferScaleDomain(type, name, values, options) {\n  const {\n    domain\n  } = options;\n  if (domain !== undefined) return domain;\n  switch (type) {\n    case 'linear':\n    case 'time':\n    case 'log':\n    case 'pow':\n    case 'sqrt':\n    case 'quantize':\n    case 'threshold':\n      return maybeMinMax(inferDomainQ(values, options), options);\n    case 'band':\n    case 'ordinal':\n    case 'point':\n      return inferDomainC(values);\n    case 'quantile':\n      return inferDomainO(values);\n    case 'sequential':\n      return maybeMinMax(inferDomainS(values), options);\n    default:\n      return [];\n  }\n}\nfunction inferScaleRange(type, name, values, options, domain, theme, library) {\n  const {\n    range\n  } = options;\n  if (typeof range === 'string') return gradientColors(range);\n  if (range !== undefined) return range;\n  const {\n    rangeMin,\n    rangeMax\n  } = options;\n  switch (type) {\n    case 'linear':\n    case 'time':\n    case 'log':\n    case 'pow':\n    case 'sqrt':\n      {\n        const colors = categoricalColors(values, options, domain, theme, library);\n        const [r0, r1] = inferRangeQ(name, colors);\n        return [rangeMin || r0, rangeMax || r1];\n      }\n    case 'band':\n    case 'point':\n      {\n        const min = name === 'size' ? 5 : 0;\n        const max = name === 'size' ? 10 : 1;\n        return [rangeMin || min, rangeMax || max];\n      }\n    case 'ordinal':\n      {\n        return categoricalColors(values, options, domain, theme, library);\n      }\n    case 'sequential':\n      return undefined;\n    case 'constant':\n      return [values[0][0]];\n    default:\n      return [];\n  }\n}\nfunction inferScaleOptions(type, name, values, options, coordinates) {\n  switch (type) {\n    case 'linear':\n    case 'time':\n    case 'log':\n    case 'pow':\n    case 'sqrt':\n      return inferOptionsQ(coordinates, options);\n    case 'band':\n    case 'point':\n      return inferOptionsC(type, name, coordinates, options);\n    case 'sequential':\n      return inferOptionsS(options);\n    default:\n      return options;\n  }\n}\nfunction categoricalColors(values, options, domain, theme, library) {\n  const [usePalette] = useLibrary('palette', library);\n  const {\n    category10: c10,\n    category20: c20\n  } = theme;\n  const defaultPalette = unique(values.flat()).length <= c10.length ? c10 : c20;\n  const {\n    palette = defaultPalette,\n    offset\n  } = options;\n  if (Array.isArray(palette)) return palette;\n  // Built-in palettes have higher priority.\n  try {\n    return usePalette({\n      type: palette\n    });\n  } catch (e) {\n    const colors = interpolatedColors(palette, domain, offset);\n    if (colors) return colors;\n    throw new Error(`Unknown Component: ${palette} `);\n  }\n}\nfunction gradientColors(range) {\n  return range.split('-');\n}\nfunction interpolatedColors(palette, domain, offset = d => d) {\n  if (!palette) return null;\n  const fullName = upperFirst(palette);\n  // If scheme have enough colors, then return pre-defined colors.\n  const scheme = d3ScaleChromatic[`scheme${fullName}`];\n  const interpolator = d3ScaleChromatic[`interpolate${fullName}`];\n  if (!scheme && !interpolator) return null;\n  if (scheme) {\n    // If is a one dimension array, return it.\n    if (!scheme.some(Array.isArray)) return scheme;\n    const schemeColors = scheme[domain.length];\n    if (schemeColors) return schemeColors;\n  }\n  // Otherwise interpolate to get full colors.\n  return domain.map((_, i) => interpolator(offset(i / domain.length)));\n}\nfunction inferOptionsS(options) {\n  const {\n    palette = 'ylGnBu',\n    offset\n  } = options;\n  const name = upperFirst(palette);\n  const interpolator = d3ScaleChromatic[`interpolate${name}`];\n  if (!interpolator) throw new Error(`Unknown palette: ${name}`);\n  return {\n    interpolator: offset ? x => interpolator(offset(x)) : interpolator\n  };\n}\nfunction inferOptionsQ(coordinates, options) {\n  const {\n    interpolate = createInterpolateValue,\n    nice = false,\n    tickCount = 5\n  } = options;\n  return Object.assign(Object.assign({}, options), {\n    interpolate,\n    nice,\n    tickCount\n  });\n}\nfunction inferOptionsC(type, name, coordinates, options) {\n  if (options.padding !== undefined || options.paddingInner !== undefined || options.paddingOuter !== undefined) {\n    return Object.assign(Object.assign({}, options), {\n      unknown: NaN\n    });\n  }\n  const padding = inferPadding(type, name, coordinates);\n  const {\n    paddingInner = padding,\n    paddingOuter = padding\n  } = options;\n  return Object.assign(Object.assign({}, options), {\n    paddingInner,\n    paddingOuter,\n    padding,\n    unknown: NaN\n  });\n}\nfunction inferPadding(type, name, coordinates) {\n  // The scale for enterDelay and enterDuration should has zero padding by default.\n  // Because there is no need to add extra delay for the start and the end.\n  if (name === 'enterDelay' || name === 'enterDuration') return 0;\n  if (name === 'size') return 0;\n  if (type === 'band') return isTheta(coordinates) ? 0 : 0.1;\n  // Point scale need 0.5 padding to make interval between first and last point\n  // equal to other intervals in polar coordinate.\n  if (type === 'point') return 0.5;\n  return 0;\n}\nfunction asOrdinalType(name, defaults) {\n  if (defaults) return defaults;\n  return isQuantitative(name) ? 'point' : 'ordinal';\n}\nfunction asQuantitativeType(name, range, defaults) {\n  if (defaults) return defaults;\n  if (name !== 'color') return 'linear';\n  return range ? 'linear' : 'sequential';\n}\nfunction maybeMinMax(domain, options) {\n  if (domain.length === 0) return domain;\n  const {\n    domainMin,\n    domainMax\n  } = options;\n  const [d0, d1] = domain;\n  return [domainMin !== null && domainMin !== void 0 ? domainMin : d0, domainMax !== null && domainMax !== void 0 ? domainMax : d1];\n}\nfunction inferDomainQ(values, options) {\n  const {\n    zero = false\n  } = options;\n  let min = Infinity;\n  let max = -Infinity;\n  for (const value of values) {\n    for (const d of value) {\n      if (defined(d)) {\n        min = Math.min(min, +d);\n        max = Math.max(max, +d);\n      }\n    }\n  }\n  if (min === Infinity) return [];\n  return zero ? [Math.min(0, min), max] : [min, max];\n}\nfunction inferDomainC(values) {\n  return Array.from(new Set(values.flat()));\n}\nfunction inferDomainO(values) {\n  return inferDomainC(values).sort();\n}\nfunction inferDomainS(values) {\n  let min = Infinity;\n  let max = -Infinity;\n  for (const value of values) {\n    for (const d of value) {\n      if (defined(d)) {\n        min = Math.min(min, +d);\n        max = Math.max(max, +d);\n      }\n    }\n  }\n  if (min === Infinity) return [];\n  return [min < 0 ? -max : min, max];\n}\n/**\n * @todo More nice default range for enterDelay and enterDuration.\n * @todo Move these to channel definition.\n */\nfunction inferRangeQ(name, palette) {\n  if (name === 'enterDelay') return [0, 1000];\n  if (name == 'enterDuration') return [300, 1000];\n  if (name.startsWith('y') || name.startsWith('position')) return [1, 0];\n  if (name === 'color') return [firstOf(palette), lastOf(palette)];\n  if (name === 'opacity') return [0, 1];\n  if (name === 'size') return [1, 10];\n  return [0, 1];\n}\nfunction isOrdinal(values) {\n  return some(values, d => {\n    const type = typeof d;\n    return type === 'string' || type === 'boolean';\n  });\n}\nfunction isTemporal(values) {\n  return some(values, d => d instanceof Date);\n}\nfunction isObject(values) {\n  return some(values, isStrictObject);\n}\nfunction some(values, callback) {\n  for (const V of values) {\n    if (V.some(callback)) return true;\n  }\n  return false;\n}\nfunction isQuantitative(name) {\n  return name.startsWith('x') || name.startsWith('y') || name.startsWith('position') || name.startsWith('size');\n}\n// Spatial and temporal position.\nexport function isPosition(name) {\n  return name.startsWith('x') || name.startsWith('y') || name.startsWith('position') || name === 'enterDelay' || name === 'enterDuration' || name === 'updateDelay' || name === 'updateDuration' || name === 'exitDelay' || name === 'exitDuration';\n}\nexport function isValidScale(scale) {\n  if (!scale || !scale.type) return false;\n  if (typeof scale.type === 'function') return true;\n  const {\n    type,\n    domain,\n    range,\n    interpolator\n  } = scale;\n  const isValidDomain = domain && domain.length > 0;\n  const isValidRange = range && range.length > 0;\n  if (['linear', 'sqrt', 'log', 'time', 'pow', 'threshold', 'quantize', 'quantile', 'ordinal', 'band', 'point'].includes(type) && isValidDomain && isValidRange) {\n    return true;\n  }\n  if (['sequential'].includes(type) && isValidDomain && (isValidRange || interpolator)) {\n    return true;\n  }\n  if (['constant', 'identity'].includes(type) && isValidRange) return true;\n  return false;\n}","map":{"version":3,"names":["Linear","createInterpolateValue","extent","max","d3ScaleChromatic","deepMix","omit","upperFirst","firstOf","lastOf","unique","defined","identity","isStrictObject","isTheta","useLibrary","inferScale","name","values","options","coordinates","theme","library","guide","type","inferScaleType","expectedDomain","inferScaleDomain","actualDomain","maybeRatio","Object","assign","inferScaleOptions","domain","range","inferScaleRange","applyScale","channels","scale","scaledValue","channel","scaleName","scaleInstance","value","V","map","d","collectScales","states","components","NONE_STATIC_KEYS","scales","Array","from","Set","flatMap","nameScale","Map","component","inferChannelsForComponent","get","staticScale","_a","independent","guide1","options1","push","useRelation","relations","isArray","invert","conditionalize","bind","funcRelations","filter","v","valueRelations","valueOutput","x","verify","has","outputValue","a","b","outputFunc","deconditionalize","assignScale","target","source","keys","getOptions","I","startsWith","replace","index","newKey","key","useRelationScale","useScale","syncFacetsScales","syncFacetsScaleByChannel","L","length","includes","S","facet","D","syncedD","every","isQuantitativeScale","isDiscreteScale","ratio","undefined","clampQuantitativeScale","clampDiscreteScale","Number","Date","Math","round","slice","names","quantitative","ordinal","isObject","asOrdinalType","isOrdinal","isTemporal","asQuantitativeType","maybeMinMax","inferDomainQ","inferDomainC","inferDomainO","inferDomainS","gradientColors","rangeMin","rangeMax","colors","categoricalColors","r0","r1","inferRangeQ","min","inferOptionsQ","inferOptionsC","inferOptionsS","usePalette","category10","c10","category20","c20","defaultPalette","flat","palette","offset","e","interpolatedColors","Error","split","fullName","scheme","interpolator","some","schemeColors","_","i","interpolate","nice","tickCount","padding","paddingInner","paddingOuter","unknown","NaN","inferPadding","defaults","isQuantitative","domainMin","domainMax","d0","d1","zero","Infinity","sort","callback","isPosition","isValidScale","isValidDomain","isValidRange"],"sources":["runtime/scale.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}