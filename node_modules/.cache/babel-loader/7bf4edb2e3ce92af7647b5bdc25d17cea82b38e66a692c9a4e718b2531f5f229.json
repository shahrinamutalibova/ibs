{"ast":null,"code":"// import { CustomElement, DisplayObjectConfig, Group } from '../../shapes';\n// import { deepMix, isNull } from '@antv/util';\n// import { maybeAppend, normalPadding, select } from '../../util';\n// import { Button } from './button';\n// import { SliderAxis } from './sliderAxis';\n// import { CellAxis } from './cellAxis';\n// import { SpeedControl } from './speedcontrol';\n// import { Checkbox } from './checkbox';\n// import { DEFAULT_TIMELINE_STYLE } from './constants';\n// import type { TimelineStyleProps, PlayAxisStyleProps } from './types';\n// import { normalSelection } from './playAxis';\nvar Timeline = /** @class */function () {\n  function Timeline() {}\n  return Timeline;\n}();\nexport { Timeline };\n// export class Timeline extends CustomElement<TimelineStyleProps> {\n//   private speed = 1;\n//   private singleMode = false;\n//   private playing = false;\n//   private selection: [number, number] = [0, 0];\n//   constructor(options: DisplayObjectConfig<TimelineStyleProps>) {\n//     super(deepMix({}, { style: DEFAULT_TIMELINE_STYLE }, options));\n//     this.singleMode = this.style.singleMode || false;\n//     this.selection = normalSelection(this.style.selection, this.singleMode);\n//   }\n//   public update(cfg: Partial<TimelineStyleProps> = {}) {\n//     this.attr(deepMix({}, this.attributes, cfg));\n//     if (cfg.singleMode !== undefined) {\n//       this.singleMode = cfg.singleMode;\n//     }\n//     if (cfg.selection) {\n//       this.selection = normalSelection(cfg.selection, this.singleMode);\n//     }\n//     this.render();\n//   }\n//   private get styles(): Required<TimelineStyleProps> {\n//     return deepMix({}, DEFAULT_TIMELINE_STYLE, this.attributes);\n//   }\n//   private render() {\n//     const { width, height, controlPosition, speedControl, singleModeControl } = this.styles;\n//     const [pt = 0, pr = 0, pb, pl = pr] = normalPadding(this.styles.padding);\n//     const container = maybeAppend(this, '.container', 'g')\n//       .attr('className', 'container')\n//       .style('x', pl)\n//       .style('y', pt)\n//       .node();\n//     const length = this.style.orientation! === 'vertical' ? height - (pt + pb) : width - (pl + pr);\n//     const layout = layoutControl(controlPosition, length, this.styles);\n//     this.renderAxis(container, layout);\n//     this.renderControlButton(container, layout);\n//     maybeAppend(container, '.timeline-speed-control', () => new SpeedControl({}))\n//       .attr('className', 'timeline-speed-control')\n//       .call((selection) => {\n//         if (speedControl === null) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as SpeedControl).update({\n//           x: layout.speedControl.x,\n//           y: layout.speedControl.y,\n//           ...speedControl,\n//           initialSpeed: this.speed,\n//         });\n//       });\n//     maybeAppend(container, '.timeline-single-control', () => new Checkbox({}))\n//       .attr('className', 'timeline-single-control')\n//       .call((selection) => {\n//         if (singleModeControl === null) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as Checkbox).update({\n//           x: layout.singleModeControl.x,\n//           y: layout.singleModeControl.y,\n//           ...singleModeControl,\n//           active: this.singleMode,\n//         });\n//       });\n//   }\n//   private renderAxis(container: Group, layout: Layout) {\n//     const { data: timeData } = this.styles;\n//     const type = this.styles.type || 'slider';\n//     let axis = select(container).select('.timeline-axis').node() as PlayAxis | undefined;\n//     const Ctor = type === 'cell' ? CellAxis : SliderAxis;\n//     if (axis && axis.style.tag !== `${type}-axis`) {\n//       axis.remove();\n//       this.removeChild(axis);\n//     }\n//     axis = maybeAppend(container, '.timeline-axis', () => new Ctor({}))\n//       .attr('className', 'timeline-axis')\n//       .call((selection) => {\n//         (selection.node() as PlayAxis).update({\n//           x: layout.axis.x,\n//           y: layout.axis.y,\n//           length: layout.axis.length,\n//           data: timeData,\n//           selection: this.selection,\n//           orientation: this.style.orientation!,\n//           playInterval: this.style.playInterval! / this.speed,\n//           singleMode: this.singleMode,\n//           ...(this.style.playAxis || {}),\n//         });\n//         (selection.node() as PlayAxis).update({\n//           handleStyle: {\n//             cursor: this.style.orientation === 'vertical' ? 'ns-resize' : 'ew-resize',\n//           },\n//         });\n//       })\n//       .node() as PlayAxis;\n//   }\n//   private renderControlButton(container: Group, layout: Layout) {\n//     const playButtonSize = layout.playBtn.size || 0;\n//     const prevButtonSize = layout.prevBtn.size || 0;\n//     const nextButtonSize = layout.nextBtn?.size || 0;\n//     maybeAppend(container, '.timeline-prev-btn', () => new Button({}))\n//       .attr('className', 'timeline-prev-btn')\n//       .call((selection) => {\n//         if (!prevButtonSize) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as Button).update({\n//           ...(this.style.controlButton?.prevBtn || {}),\n//           x: layout.prevBtn.x,\n//           y: layout.prevBtn.y,\n//           size: prevButtonSize,\n//           symbol: 'timeline-prev-button',\n//         });\n//         (selection.node() as Button).update({\n//           markerStyle: {\n//             transformOrigin: 'center',\n//             transform: this.style.orientation === 'vertical' ? 'rotate(90deg)' : '',\n//           },\n//         });\n//       });\n//     maybeAppend(container, '.timeline-play-btn', () => new Button({}))\n//       .attr('className', 'timeline-play-btn')\n//       .call((selection) => {\n//         if (!playButtonSize) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as Button).update({\n//           backgroundStyle: { radius: (layout.playBtn.size || 0) / 2 },\n//         });\n//         (selection.node() as Button).update({\n//           ...(this.style.controlButton?.playBtn || {}),\n//           x: layout.playBtn.x,\n//           y: layout.playBtn.y,\n//           size: playButtonSize,\n//           symbol: !this.playing ? 'timeline-stop-button' : 'timeline-play-button',\n//         });\n//       });\n//     maybeAppend(container, '.timeline-next-btn', () => new Button({}))\n//       .attr('className', 'timeline-next-btn')\n//       .call((selection) => {\n//         if (!nextButtonSize) {\n//           selection.remove();\n//           return;\n//         }\n//         (selection.node() as Button).update({\n//           ...(this.style.controlButton?.nextBtn || {}),\n//           x: layout.nextBtn.x,\n//           y: layout.nextBtn.y,\n//           size: nextButtonSize,\n//           symbol: 'timeline-next-button',\n//         });\n//         (selection.node() as Button).update({\n//           markerStyle: {\n//             transformOrigin: 'center',\n//             transform: this.style.orientation === 'vertical' ? 'rotate(90deg)' : '',\n//           },\n//         });\n//       });\n//     if (this.style.autoPlay && !this.playing) {\n//       this.playing = true;\n//       select(this)\n//         .select('.timeline-axis')\n//         .call((selection) => (selection.node() as PlayAxis)?.play());\n//       select(this)\n//         .select('.timeline-play-btn')\n//         .call((selection) => (selection.node() as Button)?.update({ symbol: 'timeline-play-button' }));\n//     }\n//     if (!this.style.autoPlay && this.playing) {\n//       this.playing = false;\n//       select(this)\n//         .select('.timeline-axis')\n//         .call((selection) => (selection.node() as PlayAxis)?.stop());\n//       select(this)\n//         .select('.timeline-play-btn')\n//         .call((selection) => (selection.node() as Button)?.update({ symbol: 'timeline-stop-button' }));\n//     }\n//   }\n//   private bindEvents() {\n//     const axis = select(this).select('.timeline-axis').node() as SliderAxis;\n//     const playStopBtn = select(this).select('.timeline-play-btn').node() as Button;\n//     if (playStopBtn) {\n//       select(playStopBtn).on('pointerdown', (evt: any) => {\n//         if (this.playing) {\n//           this.playing = false;\n//           axis.stop();\n//           playStopBtn.update({ symbol: 'timeline-stop-button' });\n//         } else {\n//           this.playing = true;\n//           axis.play();\n//           playStopBtn.update({ symbol: 'timeline-play-button' });\n//         }\n//       });\n//     }\n//     select(this).on('timelineStopped', () => {\n//       this.playing = false;\n//       playStopBtn?.update({ symbol: 'timeline-stop-button' });\n//     });\n//     select(this).on('speedChanged', (evt: any) => {\n//       this.speed = evt.detail.speed;\n//       axis.update({ playInterval: this.style.playInterval! / this.speed });\n//     });\n//     select(this)\n//       .select('.timeline-prev-btn')\n//       .on('pointerdown', () => axis.prev());\n//     select(this)\n//       .select('.timeline-next-btn')\n//       .on('pointerdown', () => axis.next());\n//     select(this).on('singleModeChanged', (evt: any) => {\n//       this.singleMode = evt.detail.active;\n//       this.selection = normalSelection(this.selection, this.singleMode);\n//       this.render();\n//     });\n//     select(this).on('selectionChanged', (evt: any) => {\n//       this.selection = evt.detail.selection;\n//     });\n//   }\n// }","map":{"version":3,"names":["Timeline"],"sources":["ui/timeline/index.ts"],"sourcesContent":[null],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiIA,IAAAA,QAAA;EAAA,SAAAA,SAAA,GAAuB;EAAA,OAAAA,QAAC;AAAD,CAAC,CAAxB;;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA"},"metadata":{},"sourceType":"module","externalDependencies":[]}