{"ast":null,"code":"import { group } from 'd3-array';\nimport { isParallel } from '../utils/coordinate';\nimport { LineShape, LineHV, LineVH, LineHVH, LineTrail, LineSmooth } from '../shape';\nimport { MaybeSeries, MaybeGradient } from '../transform';\nimport { baseGeometryChannels, basePostInference, basePreInference, tooltip1d, tooltipXd } from './utils';\nconst shape = {\n  line: LineShape,\n  smooth: LineSmooth,\n  hv: LineHV,\n  vh: LineVH,\n  hvh: LineHVH,\n  trail: LineTrail\n};\nconst line = (index, scale, value, coordinate) => {\n  var _a, _b;\n  const {\n    series: S,\n    x: X,\n    y: Y\n  } = value;\n  const {\n    x,\n    y\n  } = scale;\n  // Because x and y channel is not strictly required in Line.props,\n  // it should throw error with empty x or y channels.\n  if (X === undefined || Y === undefined) {\n    throw new Error('Missing encode for x or y channel.');\n  }\n  // Group data into series.\n  // There is only one series without specified series encode.\n  const series = S ? Array.from(group(index, i => S[i]).values()) : [index];\n  const I = series.map(group => group[0]).filter(i => i !== undefined);\n  // A group of data corresponds to one line.\n  const xoffset = (((_a = x === null || x === void 0 ? void 0 : x.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(x)) || 0) / 2;\n  const yoffset = (((_b = y === null || y === void 0 ? void 0 : y.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y)) || 0) / 2;\n  const P = Array.from(series, I => {\n    return I.map(i => coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]));\n  });\n  return [I, P, series];\n};\nconst parallel = (index, scale, value, coordinate) => {\n  // Extract all value for position[number] channels.\n  const PV = Object.entries(value).filter(([key]) => key.startsWith('position')).map(([, value]) => value);\n  // Because position channel is not strictly required in Line.props,\n  // it should throw error with empty position values.\n  if (PV.length === 0) {\n    throw new Error('Missing encode for position channel.');\n  }\n  // One data corresponds to one line.\n  const P = Array.from(index, i => {\n    // Transform high dimension vector to a list of two-dimension vectors.\n    // [a, b, c] -> [d, e, f, g, h, i]\n    const vector = PV.map(pv => +pv[i]);\n    const vectors = coordinate.map(vector);\n    // Two-dimension vectors are stored in a flat array, so extract them.\n    // [d, e, f, g, h, i] -> [d, e], [f, g], [h, i]\n    const points = [];\n    for (let i = 0; i < vectors.length; i += 2) {\n      points.push([vectors[i], vectors[i + 1]]);\n    }\n    return points;\n  });\n  return [index, P];\n};\n/**\n * Convert value for each channel to line shapes.\n */\nexport const Line = () => {\n  return (index, scale, value, coordinate) => {\n    const mark = isParallel(coordinate) ? parallel : line;\n    return mark(index, scale, value, coordinate);\n  };\n};\nLine.props = {\n  defaultShape: 'line',\n  defaultLabelShape: 'label',\n  composite: false,\n  shape,\n  channels: [...baseGeometryChannels({\n    shapes: Object.keys(shape)\n  }), {\n    name: 'x'\n  }, {\n    name: 'y'\n  }, {\n    name: 'position',\n    independent: true\n  }, {\n    name: 'size'\n  }, {\n    name: 'series',\n    scale: 'band'\n  }],\n  preInference: [...basePreInference(),\n  // !!!Note This order is very important.\n  {\n    type: MaybeGradient\n  }, {\n    type: MaybeSeries\n  }],\n  postInference: [...basePostInference(), ...tooltip1d(), ...tooltipXd()],\n  interaction: {\n    shareTooltip: true,\n    seriesTooltip: true,\n    crosshairs: true\n  }\n};","map":{"version":3,"names":["group","isParallel","LineShape","LineHV","LineVH","LineHVH","LineTrail","LineSmooth","MaybeSeries","MaybeGradient","baseGeometryChannels","basePostInference","basePreInference","tooltip1d","tooltipXd","shape","line","smooth","hv","vh","hvh","trail","index","scale","value","coordinate","series","S","x","X","y","Y","undefined","Error","Array","from","i","values","I","map","filter","xoffset","_a","getBandWidth","call","yoffset","_b","P","parallel","PV","Object","entries","key","startsWith","length","vector","pv","vectors","points","push","Line","mark","props","defaultShape","defaultLabelShape","composite","channels","shapes","keys","name","independent","preInference","type","postInference","interaction","shareTooltip","seriesTooltip","crosshairs"],"sources":["mark/line.ts"],"sourcesContent":[null],"mappings":"AACA,SAASA,KAAK,QAAQ,UAAU;AAChC,SAASC,UAAU,QAAQ,qBAAqB;AAGhD,SACEC,SAAS,EACTC,MAAM,EACNC,MAAM,EACNC,OAAO,EACPC,SAAS,EACTC,UAAU,QACL,UAAU;AACjB,SAASC,WAAW,EAAEC,aAAa,QAAQ,cAAc;AACzD,SACEC,oBAAoB,EACpBC,iBAAiB,EACjBC,gBAAgB,EAChBC,SAAS,EACTC,SAAS,QACJ,SAAS;AAEhB,MAAMC,KAAK,GAAG;EACZC,IAAI,EAAEd,SAAS;EACfe,MAAM,EAAEV,UAAU;EAClBW,EAAE,EAAEf,MAAM;EACVgB,EAAE,EAAEf,MAAM;EACVgB,GAAG,EAAEf,OAAO;EACZgB,KAAK,EAAEf;CACR;AAID,MAAMU,IAAI,GAASA,CAACM,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,UAAU,KAAI;;EACrD,MAAM;IAAEC,MAAM,EAAEC,CAAC;IAAEC,CAAC,EAAEC,CAAC;IAAEC,CAAC,EAAEC;EAAC,CAAE,GAAGP,KAAK;EACvC,MAAM;IAAEI,CAAC;IAAEE;EAAC,CAAE,GAAGP,KAAK;EAEtB;EACA;EACA,IAAIM,CAAC,KAAKG,SAAS,IAAID,CAAC,KAAKC,SAAS,EAAE;IACtC,MAAM,IAAIC,KAAK,CAAC,oCAAoC,CAAC;;EAGvD;EACA;EACA,MAAMP,MAAM,GAAGC,CAAC,GAAGO,KAAK,CAACC,IAAI,CAACnC,KAAK,CAACsB,KAAK,EAAGc,CAAC,IAAKT,CAAC,CAACS,CAAC,CAAC,CAAC,CAACC,MAAM,EAAE,CAAC,GAAG,CAACf,KAAK,CAAC;EAC3E,MAAMgB,CAAC,GAAGZ,MAAM,CAACa,GAAG,CAAEvC,KAAK,IAAKA,KAAK,CAAC,CAAC,CAAC,CAAC,CAACwC,MAAM,CAAEJ,CAAC,IAAKA,CAAC,KAAKJ,SAAS,CAAC;EAExE;EACA,MAAMS,OAAO,GAAG,CAAC,EAAAC,EAAA,GAAAd,CAAC,aAADA,CAAC,uBAADA,CAAC,CAAEe,YAAY,cAAAD,EAAA,uBAAAA,EAAA,CAAAE,IAAA,CAAAhB,CAAA,CAAI,KAAI,CAAC,IAAI,CAAC;EAC9C,MAAMiB,OAAO,GAAG,CAAC,EAAAC,EAAA,GAAAhB,CAAC,aAADA,CAAC,uBAADA,CAAC,CAAEa,YAAY,cAAAG,EAAA,uBAAAA,EAAA,CAAAF,IAAA,CAAAd,CAAA,CAAI,KAAI,CAAC,IAAI,CAAC;EAC9C,MAAMiB,CAAC,GAAGb,KAAK,CAACC,IAAI,CAACT,MAAM,EAAGY,CAAC,IAAI;IACjC,OAAOA,CAAC,CAACC,GAAG,CAAEH,CAAC,IACbX,UAAU,CAACc,GAAG,CAAC,CAAC,CAACV,CAAC,CAACO,CAAC,CAAC,GAAGK,OAAO,EAAE,CAACV,CAAC,CAACK,CAAC,CAAC,GAAGS,OAAO,CAAC,CAAC,CACtC;EAChB,CAAC,CAAC;EACF,OAAO,CAACP,CAAC,EAAES,CAAC,EAAErB,MAAM,CAAC;AACvB,CAAC;AAED,MAAMsB,QAAQ,GAASA,CAAC1B,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,UAAU,KAAI;EACzD;EACA,MAAMwB,EAAE,GAAGC,MAAM,CAACC,OAAO,CAAC3B,KAAK,CAAC,CAC7BgB,MAAM,CAAC,CAAC,CAACY,GAAG,CAAC,KAAKA,GAAG,CAACC,UAAU,CAAC,UAAU,CAAC,CAAC,CAC7Cd,GAAG,CAAC,CAAC,GAAGf,KAAK,CAAC,KAAKA,KAAK,CAAC;EAE5B;EACA;EACA,IAAIyB,EAAE,CAACK,MAAM,KAAK,CAAC,EAAE;IACnB,MAAM,IAAIrB,KAAK,CAAC,sCAAsC,CAAC;;EAGzD;EACA,MAAMc,CAAC,GAAGb,KAAK,CAACC,IAAI,CAACb,KAAK,EAAGc,CAAC,IAAI;IAChC;IACA;IACA,MAAMmB,MAAM,GAAGN,EAAE,CAACV,GAAG,CAAEiB,EAAE,IAAK,CAACA,EAAE,CAACpB,CAAC,CAAC,CAAC;IACrC,MAAMqB,OAAO,GAAGhC,UAAU,CAACc,GAAG,CAACgB,MAAM,CAAW;IAEhD;IACA;IACA,MAAMG,MAAM,GAAG,EAAE;IACjB,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqB,OAAO,CAACH,MAAM,EAAElB,CAAC,IAAI,CAAC,EAAE;MAC1CsB,MAAM,CAACC,IAAI,CAAC,CAACF,OAAO,CAACrB,CAAC,CAAC,EAAEqB,OAAO,CAACrB,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;IAE3C,OAAOsB,MAAM;EACf,CAAC,CAAC;EACF,OAAO,CAACpC,KAAK,EAAEyB,CAAC,CAAC;AACnB,CAAC;AAED;;;AAGA,OAAO,MAAMa,IAAI,GAAoBA,CAAA,KAAK;EACxC,OAAO,CAACtC,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,UAAU,KAAI;IACzC,MAAMoC,IAAI,GAAG5D,UAAU,CAACwB,UAAU,CAAC,GAAGuB,QAAQ,GAAGhC,IAAI;IACrD,OAAQ6C,IAAmB,CAACvC,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,UAAU,CAAC;EAC9D,CAAC;AACH,CAAC;AAEDmC,IAAI,CAACE,KAAK,GAAG;EACXC,YAAY,EAAE,MAAM;EACpBC,iBAAiB,EAAE,OAAO;EAC1BC,SAAS,EAAE,KAAK;EAChBlD,KAAK;EACLmD,QAAQ,EAAE,CACR,GAAGxD,oBAAoB,CAAC;IAAEyD,MAAM,EAAEjB,MAAM,CAACkB,IAAI,CAACrD,KAAK;EAAC,CAAE,CAAC,EACvD;IAAEsD,IAAI,EAAE;EAAG,CAAE,EACb;IAAEA,IAAI,EAAE;EAAG,CAAE,EACb;IAAEA,IAAI,EAAE,UAAU;IAAEC,WAAW,EAAE;EAAI,CAAE,EACvC;IAAED,IAAI,EAAE;EAAM,CAAE,EAChB;IAAEA,IAAI,EAAE,QAAQ;IAAE9C,KAAK,EAAE;EAAM,CAAE,CAClC;EACDgD,YAAY,EAAE,CACZ,GAAG3D,gBAAgB,EAAE;EACrB;EACA;IAAE4D,IAAI,EAAE/D;EAAa,CAAE,EACvB;IAAE+D,IAAI,EAAEhE;EAAW,CAAE,CACtB;EACDiE,aAAa,EAAE,CAAC,GAAG9D,iBAAiB,EAAE,EAAE,GAAGE,SAAS,EAAE,EAAE,GAAGC,SAAS,EAAE,CAAC;EACvE4D,WAAW,EAAE;IACXC,YAAY,EAAE,IAAI;IAClBC,aAAa,EAAE,IAAI;IACnBC,UAAU,EAAE;;CAEf"},"metadata":{},"sourceType":"module","externalDependencies":[]}