{"ast":null,"code":"/**\n * BFS nodes and execute callback.\n */\nfunction bfs(node, callback) {\n  const discovered = [node];\n  while (discovered.length) {\n    const currentNode = discovered.shift();\n    callback && callback(currentNode);\n    const children = currentNode.children || [];\n    for (const child of children) {\n      discovered.push(child);\n    }\n  }\n}\n/**\n * Hierarchy container.\n */\nexport class Node {\n  constructor(value = {}, type) {\n    // The parent node.\n    this.parentNode = null;\n    // The children nodes.\n    this.children = [];\n    // The index of parent children.\n    this.index = 0;\n    this.type = type;\n    this.value = value;\n  }\n  /**\n   * Apply specified transform to current value. Mount the node\n   * to replace the original one in the tree and then return it.\n   */\n  map(transform = x => x) {\n    const newValue = transform(this.value);\n    this.value = newValue;\n    return this;\n  }\n  /**\n   * Set or get the specified attribute. It the value is specified, update\n   * the attribute of current value and return the node. Otherwise\n   * return the the attribute of current value.\n   */\n  attr(key, value) {\n    if (arguments.length === 1) return this.value[key];\n    return this.map(v => (v[key] = value, v));\n  }\n  /**\n   * Create a new node and append to children nodes.\n   */\n  append(Ctor) {\n    const node = new Ctor({});\n    node.children = [];\n    this.push(node);\n    return node;\n  }\n  push(node) {\n    node.parentNode = this;\n    node.index = this.children.length;\n    this.children.push(node);\n    return this;\n  }\n  /**\n   * Remove current node from parentNode.\n   */\n  remove() {\n    const parent = this.parentNode;\n    if (parent) {\n      const {\n        children\n      } = parent;\n      const index = children.findIndex(item => item === this);\n      children.splice(index, 1);\n    }\n    return this;\n  }\n  getNodeByKey(key) {\n    let targetNode = null;\n    const callback = node => {\n      if (key === node.attr('key')) {\n        targetNode = node;\n      }\n    };\n    bfs(this, callback);\n    return targetNode;\n  }\n  getNodesByType(type) {\n    const nodes = [];\n    const callback = node => {\n      if (type === node.type) {\n        nodes.push(node);\n      }\n    };\n    bfs(this, callback);\n    return nodes;\n  }\n  getNodeByType(type) {\n    let node = null;\n    bfs(this, current => {\n      if (node) return;\n      if (type === current.type) node = current;\n    });\n    return node;\n  }\n  /**\n   * Apply specified callback to the node value.\n   */\n  call(callback, ...params) {\n    callback(this.map(), ...params);\n    return this;\n  }\n  getRoot() {\n    // Find the root chart and render.\n    let root = this;\n    while (root && root.parentNode) {\n      root = root.parentNode;\n    }\n    return root;\n  }\n}","map":{"version":3,"names":["bfs","node","callback","discovered","length","currentNode","shift","children","child","push","Node","constructor","value","type","parentNode","index","map","transform","x","newValue","attr","key","arguments","v","append","Ctor","remove","parent","findIndex","item","splice","getNodeByKey","targetNode","getNodesByType","nodes","getNodeByType","current","call","params","getRoot","root"],"sources":["api/node.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}