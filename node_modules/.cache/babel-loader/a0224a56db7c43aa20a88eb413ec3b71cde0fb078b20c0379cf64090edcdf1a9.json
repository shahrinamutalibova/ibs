{"ast":null,"code":"import { __read, __spreadArray } from \"tslib\";\nimport { defined, getLocalBBox, hide } from '../../../util';\nimport { isAxisHorizontal, isAxisVertical } from '../guides/line';\nimport { boundTest } from '../utils/test';\nimport { getBBox } from '../utils/bounds';\nvar methods = {\n  parity: function (items, _a) {\n    var _b = _a.seq,\n      seq = _b === void 0 ? 2 : _b;\n    return items.filter(function (item, i) {\n      return i % seq ? (hide(item), false) : true;\n    });\n  }\n};\nvar filterDefined = function (arr) {\n  return arr.filter(defined);\n};\nexport default function hideLabels(labels, overlapCfg, attr, utils) {\n  var count = labels.length;\n  var keepHeader = overlapCfg.keepHeader,\n    keepTail = overlapCfg.keepTail;\n  if (count <= 1 || count === 2 && keepHeader && keepTail) return;\n  var parityHide = methods.parity;\n  var reset = function (els) {\n    return els.forEach(utils.show), els;\n  };\n  var seq = 2;\n  var source = labels.slice();\n  var target = labels.slice();\n  var minLabelWidth = Math.min.apply(Math, __spreadArray([1], __read(labels.map(function (d) {\n    return getBBox(d).width;\n  })), false));\n  if (attr.type === 'linear' && (isAxisHorizontal(attr) || isAxisVertical(attr))) {\n    var minX = getLocalBBox(labels[0]).left;\n    var maxX = getLocalBBox(labels[count - 1]).right;\n    var distance = Math.abs(maxX - minX) || 1;\n    seq = Math.max(Math.floor(count * minLabelWidth / distance), seq);\n  }\n  var first;\n  var last;\n  if (keepHeader) first = source.splice(0, 1)[0];\n  if (keepTail) {\n    last = source.splice(-1, 1)[0];\n    source.reverse();\n  }\n  reset(source);\n  while (seq < labels.length && boundTest(filterDefined(last ? __spreadArray(__spreadArray([last], __read(target), false), [first], false) : __spreadArray([first], __read(target), false)), attr, overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin).length) {\n    // 每两步，减一个 (不需要考虑保留 first)\n    if (last && !first && seq % 2 === 0) {\n      var rest = source.splice(0, 1);\n      rest.forEach(utils.hide);\n    } else if (last && first) {\n      // 如果有 first 的话，每一步，减一个（增加迭代次数）\n      var rest = source.splice(0, 1);\n      rest.forEach(utils.hide);\n    }\n    target = parityHide(reset(source), {\n      seq: seq\n    });\n    seq++;\n  }\n}","map":{"version":3,"names":["defined","getLocalBBox","hide","isAxisHorizontal","isAxisVertical","boundTest","getBBox","methods","parity","items","_a","_b","seq","filter","item","i","filterDefined","arr","hideLabels","labels","overlapCfg","attr","utils","count","length","keepHeader","keepTail","parityHide","reset","els","forEach","show","source","slice","target","minLabelWidth","Math","min","apply","__spreadArray","__read","map","d","width","type","minX","left","maxX","right","distance","abs","max","floor","first","last","splice","reverse","margin","rest"],"sources":["ui/axis/overlap/autoHide.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}